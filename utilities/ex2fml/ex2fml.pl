#! /usr/bin/perl -w

use strict;

my $group;
my $number_of_fields;
my @field_name;
my %field_number_components;
my %field_coordinate_system;
my %field_components_names;
my %field_components_derivatives;
my %field_components_versions;
my %field_components_type_names;
my %field_components_basis;
my %field_components_modification;
my %field_components_mapping;
my %field_components_nodes;
my %field_components_number_of_parameters;
my %field_components_node_indices;
my %field_components_scale_factor_indices;
my $i;
my $j;
my $k;
my $l;
my $first;
my $values;
my $versions;
my $read_already;
my $node_template_name;
my $element_interpolation_name;
my $scale_factor_list_name;
my %scale_factor_list_lookup;
my $node_list_name;
my $element_template;
my $element_template_name;
my %element_template_lookup;
my $element_nodal_values;
my $element_nodal_values_name;
my %element_nodal_values_lookup;
my $mapping_name;
my $value_type;
my $node_name;
my $dimension;
my $shape;
my $element_name;
my $face_name;
my $node_list_number;
my %scale_factor_list_numbers;
my $number_of_scale_factor_sets;
my $mapping;
my %mapping_lookup;
my $name;
my $new_field;
my $node_index;
my $node_indices;
my $expected_number_of_nodal_values;
my $number_of_nodal_values;
my $scale_factor_indices;
my @list;
my @node_list_indices;
my @derivative_types;
my @scale_factor_list_indices;
my @value_types;
my $derivative;
my $count;
my $derivative_line;
my $basis;
my $modify;
my $index;
my $version;
my $indent;

my $line_name_offset = 100000;
my $face_name_offset = 200000;

my $in_group;
my $in_element_field;
my $node_field_defined;
my $element_field_declared;
my $element_field_defined;

my $end_match = "(Node:|Shape|Group|#Fields|Element)";

$in_group = 0;
$node_field_defined = 0;
$element_field_declared = 0;
$element_field_defined = 0;

$node_template_name = "NodeTemplate0";
$element_interpolation_name = "ElementInterpolation0";
$scale_factor_list_name = "ScaleFactorList0";
$node_list_name = "ElementNodeList";
$element_template_name = "ElementTemplate0";
$element_nodal_values_name = "ElementNodalValues0";
$mapping_name = "BasisMapping0";

my $time_var = localtime(time());
print <<FIELDML_HEADER;
<regionml>
  <fieldml xmlns="http://www.physiome.org.nz/fieldml/0.1#"
           xmlns:fieldml="http://www.physiome.org.nz/fieldml/0.1#">
  <!-- Generated by ex2fml.pl on $time_var -->
FIELDML_HEADER


$read_already = 0;
$_ = <>;
while (defined $_)
  {
	 if (m/Group name\s*:\s*(\w+)/)
	 {
		if ($in_group)
		{
		  if ($group ne $1)
		  {
			 print "</group>\n";
			 $in_group = 0;
		  }
		}
		$group = $1;
	 }

	 elsif (m"#Fields=(\d+)")
	 {
		$number_of_fields = $1;
		for ($i = 0 ; $i < $number_of_fields ; $i++)
		{
		  $_ = <>;
		  if (m"(\d+)\)\s+(\w+),\s+\w+,\s+([^,]+),[^#]*#Components=(\d)+")
		  {
			 if ($1 != $i+1)
			 {
				die ("Unable to read field header, field numbers don't match\n$_");
			 }
			 $name = $2;
			 $field_name[$i] = $2;
			 if (!defined $field_number_components{$name})
			 {
				$new_field = 1;
			 }
			 else
			 {
				$new_field = 0;
			 }
			 define_field_parameter(\$field_number_components{$name}, "number of components",
				 $4, $name, $_);
			 define_field_parameter(\$field_coordinate_system{$name}, "coordinate systems",
				 $3, $name, $_);
			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$_ = <>;
				if (m"([^\.\s][^\.]*)\.\s+Value index=\s*\d+,\s+#Derivatives=\s*(\d+)\s*(?:\(([\w/,]*)\))?(?:,\s*#Versions=\s*(\d+))?")
				{
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_derivatives{$name}[$j] = $2;
				  if (defined $3)
				  {
					 define_field_parameter(\$field_components_type_names{$name}[$j],
					   "type_names", "value,$3", $name, $_);
				  }
				  else
				  {
					 $field_components_type_names{$name}[$j] = "value";
					 for ($k = 1 ; $k <= $field_components_derivatives{$name}[$j] ; $k++)
					 {
						$field_components_type_names{$name}[$j] .= ",value_$k";
					 }
				  }
				  $field_components_versions{$name}[$j] = $4;
				}
				elsif (m"([^\.\s][^\.]*)\.\s+([^,]+),\s+([^,]+),\s+([^\.]+)\.")
				{
				  $element_field_declared = 1;
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_basis{$name}[$j] = $2;
				  define_field_parameter(\$field_components_modification{$name}[$j],
					 "component modifications", $3, $name, $_);
				  define_field_parameter(\$field_components_mapping{$name}[$j],
					 "component mappings", $4, $name, $_);
				  $_ = <>;
				  if (m"#Nodes=\s*(\d+)")
				  {
					 $field_components_nodes{$name}[$j] = $1;
					 $node_indices = "";
					 $scale_factor_indices = "";
					 for ($k = 0 ; $k < $field_components_nodes{$name}[$j] ; $k++)
					 {
						$_ = <>;
						if (m"(\d+)\.\s+#Values=\s*(\d+)")
						{
						  $node_index = $1;
						}
						else
 						{
						  die ("Unable to parse field header, could not read node index\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Value indices:\s+(\d+(\s+\d+)*)")
						{
						  $count = scalar (@list = split(/\s+/, $1));
						  @value_types = split(',', $field_components_type_names{$name}[$j]);
						  #Do not use $field_components_versions{$name}[$j] here
						  #as that is just for the last node.  If there are more values
						  #used than value types, assume that is a version.
						  for ($l = 0 ; $l < $count ; $l++)
						  {
							 $version = int(($list[$l]-1) / scalar (@value_types));
							 if ($version)
							 {
								$index = ($list[$l]-1) - $version * scalar (@value_types);
								#Write out the version index starting at 1
								$version++;
								$node_indices .= "$node_index.$version.$value_types[$index] ";
							 }
							 else
							 {
								$node_indices .= "$node_index.$value_types[$l] ";
							 }
						  }
						}
						else
						{
						  die ("Unable to parse field header, could not read value indices\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Scale factor indices:\s+(\d+(\s+\d+)*)")
						{
						  $scale_factor_indices .= "$1 ";
						}
						else
						{
						  die ("Unable to parse field header, could not scale factor indices\n$_");
						}
					 }
					 if ((scalar (@list = split(/\s+/, $node_indices))) !=
						  (scalar (@list = split(/\s+/, $scale_factor_indices))))
					 {
						die ("Unable to parse field header for $name $field_components_names{$name}[$j], number of node_indices does not match number of scale_factor_indices\nnode indices: $node_indices\nscale_factor_indices $scale_factor_indices");
					 }
					 $field_components_number_of_parameters{$name}[$j] = scalar @list;
					 $field_components_node_indices{$name}[$j] = $node_indices;
					 $field_components_scale_factor_indices{$name}[$j] = $scale_factor_indices;
				  }
				  else
				  {
					 die ("Unable to read field header, number node line didn't parse\n$_");
				  }
				}
				else
				{
				  die ("Unable to read field header, component line didn't parse\n$_");
				}
			 }
		  }
		  else
		  {
			 die ("Unable to read field header, field line didn't parse\n$_");
		  }

		  if ($new_field)
		  {
			 $name = $field_name[$i];
			 print <<FIELD_HEADER_1;
    <field name="$field_name[$i]"
           value_type="real"
           coordinate_system="$field_coordinate_system{$name}">
FIELD_HEADER_1

			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<FIELD_HEADER_2
      <component name="$field_components_names{$name}[$j]"/>
FIELD_HEADER_2
			 }
			 print <<FIELD_HEADER_3;
    </field>

FIELD_HEADER_3
		  }
		}

		$node_field_defined = 0;
		$element_field_defined = 0;

	 }

#Nodes
	 elsif (m/Node:\s*(\d+)/)
	 {
		$node_name = $1;
		$_ = <>;		
		$values = "";
		while ((defined $_) && (! /$end_match/))
		{
		  $values .= $_;
		  $_ = <>;
		}
		$read_already = 1;

		if (! $in_group)
		{
		  print <<GROUP_HEADER;
	<group name="$group">

GROUP_HEADER
        $in_group = 1;
		}

#Write the node field if the field is new or different
		if (! $node_field_defined)
		{
		  $node_template_name++;
		  $expected_number_of_nodal_values = 0;
		  print <<NODE_VALUES_FIELD_1A;
    <labels_template name="$node_template_name">
NODE_VALUES_FIELD_1A
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
			 print <<NODE_VALUES_FIELD_1B;
     <field_ref ref="$name">
NODE_VALUES_FIELD_1B

          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<NODE_VALUES_FIELD_2;
        <component_ref ref="$field_components_names{$name}[$j]">
NODE_VALUES_FIELD_2

				if (defined $field_components_versions{$name}[$j])
				  {
					 $versions = $field_components_versions{$name}[$j];
				  }
				else
				  {
					 $versions = 1;
				  }
				for ($l = 1 ; $l <= $versions ; $l++)
				{
				  $indent = "";
				  if ($versions > 1)
				  {
					 print <<NODE_VALUES_FIELD_3A;
          <label name="version_$l">
NODE_VALUES_FIELD_3A
                $indent = "  ";
				  }
				  for $value_type (split(',', $field_components_type_names{$name}[$j]))
				  {
					 print <<NODE_VALUES_FIELD_3;
$indent          <label name="$value_type"/>
NODE_VALUES_FIELD_3
					 $expected_number_of_nodal_values++;
				  }
				  if ($versions > 1)
				  {
					 print <<NODE_VALUES_FIELD_3B;
          </label>
NODE_VALUES_FIELD_3B
				  }
				}
				print <<NODE_VALUES_FIELD_5;
        </component_ref>
NODE_VALUES_FIELD_5
			 }
		  print <<NODE_VALUES_FIELD_6;
      </field_ref>
NODE_VALUES_FIELD_6
		  }
		  print <<NODE_VALUES_FIELD_7;
    </labels_template>

NODE_VALUES_FIELD_7
         $node_field_defined = 1;
		}
		
		#Strip leading and trailing whitespace
		$values =~ s/^\s+//;
		$values =~ s/\s+$//;
		#Split into the number of values.
		$number_of_nodal_values = scalar (@list = split(/\s+/, $values));
		if ($expected_number_of_nodal_values != $number_of_nodal_values)
		{
		  for $i (@list)
		  {
			 print (STDERR " Item:$i\n");
		  }
		  die ("Number of values ($number_of_nodal_values) in node $node_name does not match the expected number ($expected_number_of_nodal_values) from the header");
		}

#Write the actual node		
		print <<NODE_1;
    <node name="$node_name">
      <assign_labels template_name="$node_template_name">
$values
      </assign_labels>
    </node>

NODE_1
	 }

#Elements
	 elsif (m/Shape.\s+Dimension=(\d+)(,\s([;\w\(\)\*]*))?/)
	 {
		$dimension = $1;
		if (defined $3)
		{
		  $shape = $3;
		}
		else
		{
		  if ($dimension == 1)
		  {
			 $shape = "line";
		  }
		  elsif ($dimension == 2)
		  {
			 $shape = "line*line";
		  }
		  elsif ($dimension == 3)
		  {
			 $shape = "line*line*line";
		  }
		}
	 }

	 elsif (m"#Nodes=\s*(\d+)")
	 {
		$node_list_number = $1;
# The node list will be unique because of the element it is contained in
# rather than a different name list.
#		$node_list_name++;
      %mapping_lookup = ();
	 }

	 elsif (m"#Scale factor sets=\s*(\d+)")
	 {
		$scale_factor_list_name++;
		if (defined $1)
		{
		  $number_of_scale_factor_sets = $1;
		}
		else
		{
		  die ("Could not parse number of scale factors\n$_");
		}
		for ($i = 0 ; $i < $number_of_scale_factor_sets ; $i++)
		{
		  $_ = <>;
		  if (m"([\w\*\.\(\)\;]+),\s*#Scale factors=\s*(\d+)")
			 {
				$scale_factor_list_lookup{$1} = $scale_factor_list_name;
				$scale_factor_list_numbers{$1} = $2;
			 }
		  else
			 {
				die ("Could not parse number of scale factors\n$_");
			 }
		}
		%mapping_lookup = ();
	 }

	 elsif (m/Element:\s+(\d+)\s+(\d+)\s+(\d+)/)
	 {
		if ($element_field_declared && ! $element_field_defined)
		{
#Pre define any new mapping schemes we haven't seen before
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$basis = $field_components_basis{$name}[$j];
				$modify = $field_components_modification{$name}[$j];
				if (! $mapping_lookup{"$basis $modify"})
				{
				  $mapping_name++;
				  $mapping_lookup{"$basis $modify"} = $mapping_name;
				  $element_nodal_values_name++;
				  $element_nodal_values_lookup{"$basis $modify"} = $element_nodal_values_name;
				  if (! defined $scale_factor_list_lookup{$basis})
				  {
					 die ("No scale factor set found for basis $basis\n$_");
				  }
#           What if we don't want to start with the first scale factor
#				@scale_factor_list_indices = split(/\s+/, $field_components_scale_factor_indices{$name}[$j]);
 				  print <<MAPPING_1;
    <mapping name="$mapping_name"
             basis="$basis"
             modification="$modify">
      <coefficients>
        <product>
          <element_lookup>
            <field_lookup>
              <component_lookup>
                <label name="$element_nodal_values_name"/>
              </component_lookup>
            </field_lookup>
          </element_lookup>
          <element_lookup>
            <label name="$scale_factor_list_lookup{$basis}"/> #Need offset/split lists
          </element_lookup>
        </product>
      </coefficients>
    </mapping>

MAPPING_1
				}
			 }
		  }

        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				@node_list_indices = split(/\s+/, $field_components_node_indices{$name}[$j]);
				#Split and rejoin the values so that they have identical formatting
				$index = "@node_list_indices";
				if (! defined $element_template_lookup{$index})
				{
				  $element_template_name++;
				  $element_template_lookup{$index} = $element_template_name;
 				  print <<ELEMENT_TEMPLATE_1;
    <labels_template name="$element_template_name">
ELEMENT_TEMPLATE_1

              for ($k = 0 ; $k < $field_components_number_of_parameters{$name}[$j] ; $k++)
              {
					 if ($node_list_indices[$k] =~ m/([^.\s]+)\.([^.\s]+)\.([^.\s]+)/)
					 {
						$node_index = $1;
						$version = "version_$2";
						$value_type = $3;
				    print <<ELEMENT_TEMPLATE_2A;
      <node_lookup>
        <node>
          <element_lookup>
            <label indices="$node_list_name">
              <label indices="$node_index"/>
            </label>
          </element_lookup>
        </node>
        <field_lookup>
          <component_lookup>
            <label indices="$version">
              <label indices="$value_type"/>
            </label>
          </component_lookup>
        </field_lookup>
      </node_lookup>
ELEMENT_TEMPLATE_2A
					 }
					 elsif ($node_list_indices[$k] =~ m/([^.\s]+)\.([^.\s]+)/)
					 {
						$node_index = $1;
						$value_type = $2;
				    print <<ELEMENT_TEMPLATE_2B;
      <node_lookup>
        <node>
          <element_lookup>
            <label indices="$node_list_name">
              <label indices="$node_index"/>
            </label>
          </element_lookup>
        </node>
        <field_lookup>
          <component_lookup>
            <label indices="$value_type"/>
          </component_lookup>
        </field_lookup>
      </node_lookup>
ELEMENT_TEMPLATE_2B
                }
                else
                {
                  die ("Unable to parse node_list_indices $node_list_indices[$k]");
                }
              }
				 print <<ELEMENT_TEMPLATE_3;
    </labels_template>

ELEMENT_TEMPLATE_3

             }
			  }
		  }

#Now use these in the element interpolation
		  $element_interpolation_name++;
		  print <<ELEMENT_FIELD_1;
    <element_interpolation name="$element_interpolation_name">
ELEMENT_FIELD_1

        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
		  print <<ELEMENT_FIELD_2;
      <field_ref ref="$field_name[$i]">
ELEMENT_FIELD_2
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				@node_list_indices = split(/\s+/, $field_components_node_indices{$name}[$j]);
				#Split and rejoin the values so that they have identical formatting
				$index = "@node_list_indices";
				$element_template = $element_template_lookup{$index};
				$basis = $field_components_basis{$name}[$j];
				$modify = $field_components_modification{$name}[$j];
				$element_nodal_values = $element_nodal_values_lookup{"$basis $modify"};
				print <<ELEMENT_FIELD_3;
        <component_ref ref="$field_components_names{$name}[$j]">
          <mapping_ref ref="$mapping_lookup{"$basis $modify"}"/>
          <label name="$element_nodal_values">
            <reference_labels template="$element_template"/>
          </label>
        </component_ref>
ELEMENT_FIELD_3
			 }
		  print <<ELEMENT_FIELD_5;
      </field_ref>
ELEMENT_FIELD_5
		  }
		  print <<ELEMENT_FIELD_6;
    </element_interpolation>

ELEMENT_FIELD_6

		  $element_field_defined = 1;
		}

		if ($dimension == 1)
		{
		  $element_name = $3 + $line_name_offset;
		}
		elsif ($dimension == 2)
		{
		  $element_name = $2 + $face_name_offset;
		}
		elsif ($dimension == 3)
		{
		  $element_name = $1;
		}
		else
		{
		  die ("Unable to read element, dimension is $dimension");
		}
	
 		print <<ELEMENT_HEADER;
	 <element name="$element_name"
               shape="$shape">
ELEMENT_HEADER

      $in_element_field = 0;
		$_ = <>;
		while ((defined $_) && (! m/$end_match/))
		{
		  if (m/Faces:/)
		  {
			 print <<ELEMENT_FACES_1;
      <faces>
ELEMENT_FACES_1
			 $_ = <>;
			 $first = 1;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				if (m/(\d+)\s+(\d+)\s+(\d+)/)
				{
				  if ($dimension == 3)
				  {
					 if ($2 != 0)
					 {
						$face_name = $2 + $face_name_offset;
					 }
					 else
					 {
						$face_name = 0;
					 }
				  }
				  elsif ($dimension == 2)
				  {
					 if ($3 != 0)
					 {
						$face_name = $3 + $line_name_offset;
					 }
					 else
					 {
						$face_name = 0;
					 }
				  }
				  else
				  {
					 die ("Unable to read faces, dimension is $dimension");
				  }
				  if ($first)
				  {
					 print "$face_name";
					 $first = 0;
				  }
				  else
				  {
					 print " $face_name";
				  }
				}
				else
				{
				  die ("Unable to read face, line didn't parse\n$_");
				}
				$_ = <>;
			 }

			 print <<ELEMENT_FACES_3;

      </faces>
ELEMENT_FACES_3
		  }
 		  elsif (m/Nodes:/)
		  {
			 print <<ELEMENT_NODES_1;
      <element_interpolation_ref ref="$element_interpolation_name"/>
      <label name="$node_list_name">
ELEMENT_NODES_1
          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_NODES_3;
      </label>
ELEMENT_NODES_3
		  }
 		  elsif (m/Scale factors:/)
		  {
			 print <<ELEMENT_SCALE_2;
      <label name="$scale_factor_list_name">
ELEMENT_SCALE_2

          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_SCALE_3;
      </label>
ELEMENT_SCALE_3
		  }
		  else
		  {
			 $_ = <>;
		  }
		}

 		print <<ELEMENT_END;
    </element>

ELEMENT_END
		$read_already = 1;
	 }

	 if ($read_already)
		{
		  $read_already = 0;
		}
	 else
		{
		  $_ = <>;
		}
  }


print <<TAIL_END;
  </fieldml>
</regionml>
TAIL_END

sub define_field_parameter
{
  my $parameter_ref = shift;
  my $parameter_name = shift;
  my $new_value = shift;
  my $name = shift;
  my $line = shift;

  if (defined $$parameter_ref)
  {
	 if ($$parameter_ref ne $new_value)
	 {
		die ("Redefinition of field $name is inconsistent, $parameter_name don't match\n$line (previous $$parameter_ref) (new $new_value)");
	 }
  }
  else
  {
	 $$parameter_ref = $new_value;
  }
}
